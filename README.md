### Installation & Setup

1. Clone the repository
   git clone https://github.com/wwldavid/secure_dashboard.git
   cd secure_dashboard
2. Install dependencies
   pnpm install
3. Configure environment variables

   PostgreSQL database connection (Railway)
   DATABASE_URL=

   AES-GCM encryption key (32-byte hex string)
   CRYPTO_KEY=

   NextAuth.js session secret & base URL
   NEXTAUTH_SECRET=
   NEXTAUTH_URL=http://localhost:3000

   the keys could be generated by:
   32-byte hex:
   node -e "console.log(require('crypto').randomBytes(32).toString('hex'))"
   32-byte base64:
   openssl rand -base64 32

4. Initialize the database (Make sure database is running)
   npx prisma migrate dev --name init
   npx prisma studio
5. Start the development server
   npm run dev
   The app will be available at http://localhost:3000.
   Visit /signup to register a new user
   Visit /login to sign in
   Visit /dashboard to view and update your profile (requires authentication)

### Input Validation Techniques

    To ensure only safe and expected data ever reaches our database or rendering layer, I use validation both in the browser and again on the server.

#### Client-side Validation (React Form)

     using controlled inputs and simple checks in ProfileForm.
     in handleSubmit I trim values and then:

      if (form.name.trim().length < 3 || form.name.trim().length > 30) {
      setError("Name must be between 3 and 30 characters.");
      return;
      }
      if (!/^[A-Za-z ]+$/.test(form.name.trim())) {
      setError("Name may only contain letters and spaces.");
      return;
      }
      same for email format and bio length/no-tags

#### Server-side Validation (API Route)

     I manually parse req.json() then run these checks:
     if ( typeof name !== "string" ||
     name.trim().length < 3 ||
     name.trim().length > 30 ||
     !/^[A-Za-z ]+$/.test(name.trim())
     ) {
       errors.push({
         param: "name",
         msg: "Name must be 3–30 letters or spaces only",
       });
     }
     // Email: basic RFC-compatible regex
     if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email.trim())) {
     errors.push({ param: "email", msg: "Invalid email format" });
     }
     // Bio: ≤800 chars, no < or >
     if (bio.length > 800 || /[<>]/.test(bio)) {
     errors.push({
     param: "bio",
     msg: "Introduction must be ≤800 characters and not include < or >",
     });
     }
     Returns 400 with structured JSON errors if any rule fails.

### Output encoding methods

    To prevent any client-side code injection (XSS) when displaying user-provided text, I rely on two main techniques:
    React’s Built-in Escaping (By default, React’s JSX interpolation already escapes outputs, covering most use-cases.)
    Manual Sanitization for Raw HTML Insertion(unnecessary, since I am building this project with react)

### Encryption techniques

    All sensitive user data (“email” and “bio”) is encrypted using AES-256-GCM.

#### Key Management

     CRYPTO_KEY  is a 32-byte hex string stored in your .env.local.

#### Encryption / Decryption(lib/crypto.js)

     import crypto from "crypto";
     const KEY = Buffer.from(process.env.CRYPTO_KEY, "hex");
     const ALGO = "aes-256-gcm";
     export function encrypt(text) {
       const iv     = crypto.randomBytes(12);
       const cipher = crypto.createCipheriv(ALGO, KEY, iv);
       const encrypted = Buffer.concat([
         cipher.update(text, "utf8"),
         cipher.final(),
       ]);
       const tag = cipher.getAuthTag();
       return Buffer.concat([iv, tag, encrypted]).toString("base64");
     }
     export function decrypt(data) {
       const buf = Buffer.from(data, "base64");
       const iv        = buf.slice(0, 12);
       const tag       = buf.slice(12, 28);
       const encrypted = buf.slice(28);
       const decipher = crypto.createDecipheriv(ALGO, KEY, iv);
       decipher.setAuthTag(tag);
       return decipher.update(encrypted, null, "utf8") + decipher.final("utf8");
     }

### Third-party libraries dependency management

    1. Local Audit & Fix
       npm config set registry https://registry.npmjs.org/
       npm audit
       npm audit fix
    2. Automated Security Checks (GitHub Actions)

### Lessons Learned

1. I run into severals times JWT decryption errors “decryption operation failed”, when 'getServerSession' couldn’t decrypt old cookies. Finally I found that the reason is my old cookies, I have to clear my cookies entirely in my localstorage.

2. express-validator
   req.body could only be read could not be changed within react component.
   Using express-validator in Next.js Route Handlers collided with the readonly nature of req.body and req.json() streams. Finally I have to gave up express-validator and manually write check code for the input fields.

3. Output encoding in React  
   Learned that React auto-escapes all interpolated values in JSX. Reserved `escape-html` only for genuine raw-HTML insertions.

### Project Building Process

1. npx create-next-app@latest secure-dashboard

2. npm install tailwindcss @tailwindcss/postcss postcss

3. npm install next-auth @prisma/client prisma express-validator escape-html

### Define the database schema/model

4.  touch .env (DATABASE_URL from Railway)

5.  npm install prisma @prisma/client --save-de

6.  npx prisma init

7.  add model User in schema.prisma, then run: npx prisma migrate dev --name add_user_model

8.  npx prisma studio （Check if the database was created successfully.）

### Wrap encryption and decryption functions into a utility

9. create lib/crypto.js

10. Generate a 32-byte (256-bit) random key
    node -e "console.log(require('crypto').randomBytes(32).toString('hex'))"
    Save it to .env file as an environment variable

### NextAuth.js

11. npm install next-auth bcrypt @prisma/client

12. Add two fields to the User model: email String @unique and passwordHash String.
    npx prisma migrate dev --name add_email_and_password

13. openssl rand -base64 32
    add NEXTAUTH_SECRET in .env

14. npm install bcrypt

### Dashboard

### ProfileForm

15. npm install escape-html (Prevent Cross-Site Scripting (XSS) attacks)

### Profile Api

### Testing and Debugging

    XSS Test: Enter <script>alert(1)</script> in the bio field.The front-end return "Introduction must be ≤800 characters and not include < or >"  without triggering a popup.

    SQL Injection Test: Enter Robert'); DROP TABLE Users;-- in the name field. The request was rejected with a 400 status code and with a message "Name must be 3-30 letters or spaces only"

16. npm audit
    npm warn audit 404 Not Found - POST https://registry.npmmirror.com/-/npm/v1/security/advisories/bulk - [NOT_IMPLEMENTED] /-/npm/v1/security/_ not implemented yet
    { error: '[NOT_IMPLEMENTED] /-/npm/v1/security/_ not implemented yet' }
    npm error audit endpoint returned an error
    npm error A complete log of this run can be found in: /Users/wanlongwu/.npm/\_logs/2025-08-01T21_52_50_925Z-debug-0.log
17. npm audit --registry=https://registry.npmjs.org/
    found 0 vulnerabilities
18. npm config set registry https://registry.npmjs.org/
19. npm install
20. npm audit
    found 0 vulnerabilities
21. npm audit fix

### GitHub Actions

    create audit.yml

22. mkdir -p .github/workflows
